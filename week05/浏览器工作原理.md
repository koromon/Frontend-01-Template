# 浏览器工作原理

浏览器工作过程：

![](https://blog-1257793372.cos.ap-guangzhou.myqcloud.com/1589383178_20200512214704419_430648659.png)

1. 浏览器使用 HTTP/HTTPS 协议向服务端请求页面；
2. 把请求回来的 HTML 代码经过解析，构建成 DOM 树；
3. 计算 DOM 树上的 CSS 属性；
4. 根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；
5. （可选）对位图进行合成，这会极大增加后续绘制的速度；
6. 合成之后，再绘制到界面上。

HTTP 请求到数据后，后续的流程就开始流式的处理前一步的产出，并不需要等到全部数据返回才开始处理。

## 1. HTTP 协议

HTTP 协议属于 TCP/IP 协议，先简单了解一些基本概念。

**ISO/OSI 七层网络模型**

[OSI 模型](https://zh.wikipedia.org/wiki/OSI模型)是一种概念模型，一个试图使各种计算机在世界范围内互连为网络的标准框架。

但是在实际网络传输过程中，我们使用的是简化后的 [TCP/IP](https://zh.wikipedia.org/wiki/TCP/IP协议族) 四层模型（下方的序列是对应关系不是包含关系）：

- 应用层
  - 对应 OSI 模型最上面三层（应用层/表示层/会话层）
  - 常见协议有 HTTP/FTP 协议（Node 中通过 `require('http')` 访问）
- 传输层
  - 对应 OSI 模型的传输层
  - 常见协议有 TCP 协议（Node 中通过 `require('net')` 访问）
- 网络互连层
  - 对应 OSI 模型的网络层
  - 常见协议有 IP 协议
- 数据链路层
  - 对应 OSI 模型的数据链路和物理层
  - 例如以太网、WIFI

**TCP 与 IP 的一些基础知识**

- TCP

  - 流（流式传输）
  - 端口（标识应用）
  - `require('net')`（可以在 `node` 访问）

- IP
  - 包（IP 发送单位）
  - IP 地址（标识 IP）
  - `libnet/libpcap`（通过 `C++` 访问）

HTTP 协议大致可以划分成如下部分：

![3db5e0f362bc276b83c7564430ecb0a1](https://blog-1257793372.cos.ap-guangzhou.myqcloud.com/1589986938_20200520223732506_1223634900.jpg)

### Request

- Request line（`POST /path HTTP/1.1`）
- headers（`Host: 127.0.0.1`、`Content-Type: application/xxxx`）
- 空行
- body（`field1=aaa&code=x%3D1`）
- 空行

### Response

- status line（`HTTP/1.1 200 OK`）
- headers
- 空行
- body
- 空行

## 2. 语法与词法分析

浏览器工作的第一个阶段是通讯的部分：通过 HTTP/HTTPS 协议向服务端请求页面。

而第二个阶段就是解析返回的 HTML 代码以及构建 DOM 树。

![34231687752c11173b7776ba5f4a0e5a](https://blog-1257793372.cos.ap-guangzhou.myqcloud.com/1589986938_20200520224844740_588659505.png)

### 词法分析

为了正确的解析代码，浏览器需要通过[状态机](https://zh.wikipedia.org/wiki/有限状态机)把字符流解析成词（token），这个状态机满足了[HTML 官方文档](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)的定义。

**有限状态机处理字符串**

有限状态机的特点：

- 每一个状态都是独立的一个机器
  - 在每一机器里，我们可以做计算、存储、输出...
  - 所有的这些机器接受的输入是一致的
  - 状态机的每一个机器本身没有状态，如果我们用函数来表示的话，它应该是纯函数（无副作用）
- 每一个机器都知道下一个状态（两种类型）
  - 每个机器都有确定的下一个状态（Moore）
  - 每个机器根据输入决定下一个状态（Mealy）

**JavaScript 中的有限状态机(Mealy）**

```
// 每个函数是一个状态
function state(input) {
  // 函数参数就是输入
  // 在函数中，可以自由地编写代码，处理每个状态的逻辑
  return next; // 返回值作为下一个状态，如果返回值是固定的就是 Moore 型状态机 ，如果返回值和 input 有关就是 Mealy 型状态机
}

// 调用
while (input) {
  // 获取输入
  state = state(input); // 把状态机的返回值作为下一个状态
}
```

**参考名词**

1. [Mealy](https://zh.wikipedia.org/wiki/米利型有限状态机) ：在计算理论中，米利型有限状态机（英语：Mealy machine）是基于它的当前状态和输入生成输出的有限状态自动机（更精确的叫有限状态变换器）。这意味着它的状态图将为每个转移边包括输入和输出二者。与输出只依赖于机器当前状态的摩尔有限状态机不同，它的输出与当前状态和输入都有关。但是对于每个 Mealy 机都有一个等价的 Moore 机，该等价的 Moore 机的状态数量上限是所对应 Mealy 机状态数量和输出数量的乘积加 1（|S’|=|S|\*|Λ|+1）。

### 构建 DOM 树

接下来浏览器要把这些简单的词变成 DOM 树，这个过程是使用栈来实现的。

浏览器通过 HTML 语法分析器接收上一步中词法分析器产生的词（token）。在接收的同时就开始构建 DOM 树，当接收完所有输入，栈顶就是最后的根节点，DOM 树的产出就是这个栈的第一项。

## 3. CSS 计算

浏览器工作的第二个步骤中，开始构建 DOM 树，但这个 DOM 的实际信息是不完整的，只包含了节点和属性，所以第三步需要把 CSS 规则应用到节点上。

特别要注意的是 CSS 规则并不是等 DOM 树构建完成才开始添加样式（要注意浏览器会流式的处理整个过程加快响应），而是每当有一个元素节点创建，就会去检查它匹配到哪些规则，再根据规则的优先级做覆盖和调整。

同样的 CSS 也需要经过词法分析和语法分析才能变成计算机理解的结构，我们可以参考 [CSS Parser](https://www.npmjs.com/package/css) 来了解这个解析规则。

1. 收集 CSS 规则
   1. 遇到 `style` 标签时，我们把 CSS 规则保存起来（还要考虑 `link` 标签的请求）
   2. 借助 [CSS Parser](https://www.npmjs.com/package/css) 来分析 CSS 规则，但是我们要仔细研究此库分析 CSS 规则的格式
2. 添加调用
   1. 当我们创建一个元素后，立即计算 CSS（最佳实践：样式尽可能提前写）
   2. 理论上当我们分析一个元素时，所有 CSS 规则已经收集完毕
   3. 在真实浏览器中，可以遇到写在 body 的 `style` 标签，需要重新计算 CSS 的情况
3. 获取父元素序列
   1. 在 `computeCSS` 函数中，我们必**须知道元素所有父元素**才能判断元素与规则是否匹配
   2. 我们可以从 `parent` 属性获取元素父属性。（简化：从上一步骤的 `stack` 中获取本元素所有的父元素）
   3. 因为首先获取的是“当前元素”，所以我们获得和计算父元素匹配的顺序是从内向外
4. 拆分选择器
   1. 选择器要和元素匹配顺序一致，从当前元素向外排列
   2. 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列
5. 计算选择器与元素匹配
   1. 根据选择器的类型和元素属性，就算是否与当前元素匹配
   2. 实际浏览器要考虑多种选择器
6. 生成 computed 属性
   1. 一旦选择匹配，就应用选择器到元素上，形成 `computedStyle`
7. 确定规则覆盖关系
   1. [确定规则](https://www.w3.org/TR/CSS2/cascade.html#specificity)

经过上面这些步骤，浏览器就得到了一棵带有 CSS 属性的树。

## 4. CSS 排版、渲染、合成

。。。

## 参考资料

1. [HTTP1.1 标准](https://tools.ietf.org/html/rfc2616)
2. [HTTPS 标准](https://tools.ietf.org/html/rfc2818)
3. [HTTP2 标准](https://tools.ietf.org/html/rfc7540)
